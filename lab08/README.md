# Stop and wait protocol

Реализации серверного и клиентского кода находятся
в файлах `server.py` и `client.py`

ВАЖНО - сначала создаем `Server`, вызываем у него блокирующий `accept()`. Далее можно создавать клиента, который подключится к серверу. Если `accept()` завершился без проблем, то это значит, что к серверу  подключился клиент, с которым можно начать общение.

## Server

1. Создаем класс `Server`, передав ему порт и таймаут в качестве аргументов конструктора
2. Вызываем `accept()`, чтобы начать общение с клиентом. Без вызова `accept()` и попытке записать или прочитать данные из сокета будет выброшено исключение, так как к сокету никто не подключен. Общение по текущему сокету будет только с первым клиентом, подключенным в `accept()`. Повторый вызов `accept()` выбросит исключение
3. Общаемся с клиентом с помощью функций `read()` и `write()`

## Client

1. Создаем класс `Client`, передав ему адресс и порт сервера, а также таймаут в качестве аргументов конструктора
2. Общаемся с сервером с помощью функций `read()` и `write()`

## Тест

Клиент и сервер обмениваются по одному файлу и затем проверяют полученные файлы на равенство с оригиналами.

### Как запустить

Сначала запускаем серверную часть
```shell
cd test
python3 server_test.py
```

Потом клиентскую
```shell
cd test
python3 client_test.py
```

Оба теста должны вывести в конце `OK!`
