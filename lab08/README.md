# Stop and wait protocol

Реализации серверного и клиентского кода находятся
в файлах `server.py` и `client.py` (Реализации не потокобезопасны!)

ВАЖНО - сначала создаем `Server`, вызываем у него блокирующий `accept()`.
Далее можно создавать клиента, который подключится к серверу.
Если `accept()` завершился без проблем, то это значит, что к серверу
подключился клиент, с которым можно начать общение.

## Server

1. Создаем класс `Server`,
передав ему порт и таймаут в качестве аргументов конструктора
2. Вызываем `accept()`, чтобы начать общение с клиентом.
Без вызова `accept()` и попытке записать или прочитать данные
из сокета будет выброшено исключение, так как к сокету никто
не подключен. Общение по текущему сокету будет только с первым
клиентом, подключенным в `accept()`. Повторый вызов `accept()` выбросит исключение
3. Общаемся с клиентом с помощью функций `read()` и `write()`

## Client

1. Создаем класс `Client`, 
передав ему адресс и порт сервера, а также таймаут в качестве аргументов конструктора
2. Общаемся с сервером с помощью функций `read()` и `write()`

## Тест

Клиент и сервер обмениваются по одному файлу и затем проверяют 
полученные файлы на равенство с оригиналами.

### Как запустить

Сначала запускаем серверную часть
```shell
cd test
python3 server_test.py
```

Потом клиентскую
```shell
cd test
python3 client_test.py
```
